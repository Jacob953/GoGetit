# 2. Sort - 排序

排序是生活中最常见的算法，可能现在你还没有接触过排序算法，但当你深入学习时，你发现它有种莫名的熟悉感。

排序算法数不胜数，短短一节肯定无法面面俱到，本节只会对最经典的排序算法进行介绍。

在介绍排序算法之前，我还需要向你简单说明一下排序算法的衡量指标。

## Go - 排序算法的指标

通常情况下，我们需要对排序算法的执行效率、内存消耗和稳定性进行比较：

### Go - 排序算法的执行效率

1. 最好、最坏、平均情况时间复杂度

2. 时间复杂度的系数、常数、低阶

3. 比较次数和移动（交换）次数 

现实中的排序算法应该充分考虑数据的特点，同样的算法，面对不同数据的表现往往是不同的。

### Go - 排序算法的内存消耗

- 原地排序：空间复杂度为 O(1) 的排序算法，即不需要额外的存储空间

需要消耗额外内存的排序算法往往更加稳定、效果更优，但是内存并不是无限的，面对 TB 级的数据量，非原地排序算法就会显得格外奢侈。

### Go - 排序算法的稳定性

- 前提条件：假设原序列中存在值相等的元素。

- 判断依据：值相同的元素在排序算法结束后，原有的先后关系是否发生变化。

面对复杂的业务，当需要使用多种排序算法时，具有稳定性的算法着能继承前一次排序的结果。

## 排序算法的分类

接下来，我会按照排序算法的执行效率来介绍：

### Go - 时间复杂度 O(n<sup>2</sup>) 级

**冒泡排序**

步骤：每次只会对相邻的两个数据进行比较和交换

```Golang
func bubblesort(n []int){
    
}

```

**插入排序**

**选择排序**

### Go - 时间复杂度 O(nlogn) 级

**归并排序**

**快速排序**

**堆排序**

### Go - 时间复杂度 O(n) 级

**桶排序**

**计数排序**

**基数排序**